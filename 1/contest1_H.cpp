/*
Отдел Тайн Министерства магии состоит из двух стеллажей A и B. Известно, что в стеллаже A пророчества на каждой 
полке отсортированы по порядку времени, когда они были созданы. А в стеллаже B
 пророчества на каждой полке отсортированы с точностью до наоборот. В стеллаже An полок, а в B — m полок. 
 При этом в обоих стеллажах все полки вмещают по l пророчеств.
Тому, кого нельзя называть, известно, что все пророчества в отделе тайн хранятся в виде двух частей: одна в стеллаже A, 
другая — в B. Также он знает, что половинки пророчеств соединяются следующим образом: на полках Ai и Bj
 половинки пророчества соответствуют друг другу, если найти такое k, что max(Aik,Bjk) минимален. Тогда такие Aik,Bjk
 и будут нужными пророчествами. Если таких k несколько, то подойдет любое.Так как Тому Реддлу осталось недолго, 
 он просит вас искать такие k
 на его запросы вида (i,j).
  Формат ввода
На первой строке числа n,m,l (1≤n,m≤900;1≤l≤3000). Следующие n строк содержат описания полок Ai.
Каждая полка описывается перечислением l элементов. Время записи пророчеств — целые числа от 0 до 10^5−1. Далее число 
m и описание массивов Bj в таком же формате.Полки и элементы внутри массива нумеруются с 1.
На следующей строке число запросов Тома Реддла q (1≤q≤n⋅m). Следующие q строк содержат пары чисел i,j (1≤i≤n, 1≤j≤m).
  Формат вывода
Выведите q чисел от 1 до l – ответы на запросы.
  Пример
Ввод
4 3 5
1 2 3 4 5
1 1 1 1 1
0 99999 99999 99999 99999
0 0 0 0 99999
5 4 3 2 1
99999 99999 99999 0 0
99999 99999 0 0 0
12
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
4 1
4 2
4 3

Вывод
3
4
3
5
4
3
1
2
2
4
4
3
*/

#include <iostream>

int BinarySearch(long long arr_a[], long long arr_b[], int left, int right) {
  while (right - left != 1) {
    int mid = (right + left) / 2;
    (arr_a[mid] >= arr_b[mid]) ? right = mid : left = mid;
  }
  if (std::max(arr_a[left], arr_b[left]) >
      std::max(arr_a[right], arr_b[right])) {
    return right + 1;
  }
  return left + 1;
}

int n, m, l, q;
int i, j;
long long a[900][3000];
long long b[900][3000];

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  std::cin >> n >> m >> l;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < l; j++) {
      std::cin >> a[i][j];
    }
  }
  for (int i = 0; i < m; i++) {
    for (int j = 0; j < l; j++) {
      std::cin >> b[i][j];
    }
  }
  std::cin >> q;
  for (int iter = 0; iter < q; iter++) {
    std::cin >> i >> j;
    std::cout << BinarySearch(a[i - 1], b[j - 1], 0, l - 1) << "\n";
  }
  return 0;
}
